/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 * This code is mainly inspirated by:
 *  http://www.fi.muni.cz/~xslaby/phantom.html
 */

#include <linux/compat.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/device.h>
#include <linux/pci.h>
#include <linux/fs.h>
#include <linux/poll.h>
#include <linux/interrupt.h>
#include <linux/cdev.h>
#include <linux/slab.h>
#include <linux/phantom.h>
#include <linux/sched.h>
#include <linux/smp_lock.h>

#include <asm/atomic.h>
#include <asm/io.h>

#define DUMMY_VENDOR_ID             0x104C
#define DUMMY_DEVICE_ID             0xA106
#define DUMMY_CLASS_ID              0x0880 // ??

#define DUMMY_MAX_MINORS    1
#define DUMMY_VERSION       1

//static struct class *dummy_class;

struct dummy_device {
	unsigned int opened;
	u32 __iomem *addr_b0;
	u32 __iomem *addr_b1;
	u32 __iomem *addr_b2;//
	u32 __iomem *iaddr;
	u32 __iomem *oaddr;


	unsigned long status;
	atomic_t counter;
    wait_queue_head_t wait;

	struct mutex open_lock;
	spinlock_t regs_lock;
};



/*----------------- TESTOVACI FCE ----------------- START*/

static unsigned char get_dev_revision(struct pci_dev *pdev)
{
	u8 revision;
	//navratova hodnota lze perlozit pres pcibios_strerror
	//vraci bud 0 nebo error kod
	pci_read_config_byte(pdev,PCI_REVISION_ID,&revision);
	//pci_read_config_byte(pdev,0,&revision);
	printk("PCI_REVISION_ID %i \n",PCI_REVISION_ID);
	return revision;
}
static unsigned char set_dev_revision(struct pci_dev *pdev, u8 revision)
{
	printk("new revision id %i \n",revision);

	return pci_write_config_byte(pdev,PCI_REVISION_ID,revision);
	
	//return pci_write_config_byte(pdev,0,revision);
	
}
static int dummy_pci_dspreset(struct pci_dev *pdev,struct dummy_device *pht)
{
	u32 __iomem *HDCR,*PWRSTATE;
	int int_tmp=0;
	HDCR=pht->addr_b2+0x04;
	int_tmp=ioread8(HDCR);
	printk("Dummy warm reset|warmreset=%x \n",int_tmp);
	iowrite8(0x01,HDCR);
	int_tmp=ioread8(HDCR);
	printk("Dummy warm reset|warmreset=%x \n",int_tmp);


	//PWRSTATE=pht->
		

	
	return 1;

}

static int dummy_pci_iotest(struct pci_dev *pdev,struct dummy_device *pht)
{
	int int_tmp=0;
	int i=0;
//	int code_arr[]={0x20,0x00,0x00,0x00,0x01,0x85,0x00,0x2A,0x01,0x80,0x00,0x6A,0x00,0x0C,0x03,0x62,0x00,0x40,0x03,0xE2,0x02,0x80,0x03,0xA2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88};
int hexprog[3000]={0x20,0x00,0x00,0x00,0x01,0x85,0x00,0x2A,0x01,0x80,0x00,0x6A,0x00,0x0C,0x03,0x62,0x00,0x40,0x03,0xE2,0x02,0x80,0x03,0xA2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x20,0x00,0x20,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAE,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8E,0x20,0x00,0x60,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x20,0x00,0x80,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4E,0x20,0x00,0xA0,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x20,0x00,0xC0,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x20,0x00,0xE0,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEE,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xCD,0x20,0x01,0x20,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAD,0x20,0x01,0x40,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8D,0x20,0x01,0x60,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6D,0x20,0x01,0x80,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4D,0x20,0x01,0xA0,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2D,0x20,0x01,0xC0,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0x20,0x01,0xE0,0x00,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xED,0x20,0x07,0x20,0x00,0x0F,0xBC,0x1F,0xD9,0x05,0xBC,0x94,0xF5,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x05,0x7C,0x60,0x75,0x05,0x3C,0x23,0xC7,0x05,0x8C,0x0F,0xDA,0xAF,0x20,0x07,0x40,0x00,0x05,0x10,0x06,0xA1,0x00,0x13,0xEA,0x58,0xC0,0x20,0x21,0x23,0x01,0x00,0x0F,0xD9,0x00,0x80,0x06,0xA1,0xD0,0x28,0x02,0x64,0x80,0x04,0xA3,0x58,0xA1,0xFF,0xFF,0xA8,0x30,0x20,0x07,0x60,0x00,0xA1,0xFF,0xFF,0xE8,0xD0,0x00,0x0B,0x11,0x91,0x80,0x0F,0xD8,0x00,0x00,0x80,0x00,0x00,0x00,0x38,0x11,0x05,0x28,0x80,0x58,0x02,0x28,0x36,0x64,0x00,0x00,0x40,0x00,0x3C,0x20,0x07,0x80,0x00,0x03,0x0C,0x0F,0xD9,0x05,0x8C,0x06,0xA1,0x02,0x28,0x1F,0xDB,0x01,0x84,0x01,0x62,0x01,0xA9,0x60,0x78,0x01,0x8C,0xE0,0x58,0x05,0x0F,0x0F,0x58,0x00,0x28,0x36,0x64,0x9A,0x20,0x07,0xA0,0x00,0x00,0x00,0x60,0x00,0xCF,0xFF,0xFC,0x10,0xC0,0x00,0x30,0x10,0xC2,0x28,0x36,0x64,0x01,0x80,0x0F,0xD8,0x00,0x00,0x20,0x00,0x01,0xFF,0xFF,0xA8,0x01,0xFF,0xFF,0xE8,0x65,0x20,0x07,0xC0,0x00,0x00,0x0F,0xEA,0x58,0xC0,0x11,0x41,0x21,0x00,0x80,0x0F,0xD9,0xD0,0x0C,0x02,0x64,0x95,0x0C,0x1F,0xDA,0x80,0x04,0xA3,0x58,0xD0,0x00,0x08,0x91,0x90,0x00,0x1F,0xDA,0xE0,0x20,0x07,0xE0,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x03,0x62,0x00,0x00,0x60,0x00,0x01,0x84,0x01,0x62,0x00,0x28,0x32,0xE6,0x00,0x00,0x60,0x00,0x20,0x00,0x01,0x90,0x20,0x00,0x03,0x62,0xF6,0x20,0x08,0x00,0x00,0x00,0x00,0x60,0x00,0x01,0xAC,0x0F,0xDB,0x0F,0xBC,0x1F,0xD8,0x00,0x0C,0x03,0x63,0x05,0x7C,0x22,0x65,0x05,0x3C,0x23,0xE6,0x05,0xBC,0x92,0xE4,0x00,0x00,0x60,0x00,0xC4,0x20,0x08,0x20,0x00,0x05,0x3C,0x94,0xF6,0x05,0x3C,0x23,0xC4,0x02,0x05,0xC8,0x2A,0x02,0x00,0x00,0x6A,0x02,0x10,0x02,0xE6,0x00,0x00,0x60,0x00,0x00,0x10,0x03,0x62,0x01,0x88,0x81,0x62,0x25,0x20,0x08,0x40,0x00,0x01,0x85,0x80,0x28,0x01,0x80,0x00,0x68,0x00,0x0C,0x02,0x64,0x02,0x85,0x82,0x2A,0x02,0x80,0x00,0x6A,0x00,0x00,0x20,0x00,0x02,0x00,0x1F,0xDB,0xD0,0x00,0x0A,0x90,0x6A,0x20,0x08,0x60,0x00,0x05,0x14,0x9C,0x42,0xC2,0x28,0x34,0xE6,0x05,0x00,0x0F,0xD8,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x03,0x62,0x01,0x88,0x81,0x63,0x00,0x00,0x00,0x00,0x8F,0x20,0x08,0x80,0x00,0x00,0x2B,0xE0,0x59,0x05,0x2B,0xE1,0xA0,0xCF,0xFE,0x81,0x21,0xC2,0x28,0x34,0xE6,0xC0,0x10,0x03,0x62,0x01,0x85,0xC6,0x28,0x01,0x80,0x00,0x68,0x00,0x0C,0x02,0x64,0xCC,0x20,0x08,0xA0,0x00,0x00,0x00,0x60,0x00,0xD1,0x85,0xC4,0x29,0xD0,0x00,0x06,0x12,0xC0,0x00,0x13,0x63,0xD1,0x80,0x00,0x68,0xD0,0x0C,0x02,0x64,0x00,0x00,0x40,0x00,0x01,0x88,0x01,0x62,0x50,0x20,0x08,0xC0,0x00,0x01,0x85,0xC4,0x28,0x01,0x80,0x00,0x68,0x00,0x0C,0x02,0x64,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0xD1,0x85,0xCA,0x29,0xD0,0x00,0x08,0x12,0xC0,0x00,0x13,0x63,0xA2,0x20,0x08,0xE0,0x00,0xD1,0x80,0x00,0x68,0xD1,0x8C,0x02,0x64,0x00,0x00,0x40,0x00,0x01,0x84,0x01,0x62,0x01,0x85,0xCA,0x28,0x01,0x80,0x00,0x68,0x01,0x8C,0x02,0x64,0x00,0x00,0x40,0x00,0xC0,0x20,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x13,0x62,0x01,0x83,0x81,0x62,0x00,0x00,0x3C,0x10,0x01,0x85,0x81,0x62,0x00,0x05,0xA1,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x20,0x09,0x20,0x00,0x00,0x18,0x29,0xF1,0x00,0x98,0x47,0xA1,0x04,0x04,0xA3,0x58,0xC1,0x90,0x36,0xA5,0xC4,0x00,0x01,0x29,0x04,0x90,0x1F,0xD8,0x82,0x90,0x56,0xA7,0x84,0xA5,0x0A,0x25,0xF6,0x20,0x09,0x40,0x00,0x00,0x18,0x79,0xA3,0x01,0x18,0x87,0xA0,0xA8,0x10,0x37,0xB5,0x02,0x90,0x08,0xF1,0x04,0x00,0x16,0xA1,0x00,0x84,0xA3,0x5A,0x23,0x90,0x37,0xA5,0x20,0x03,0xE1,0xA3,0x82,0x20,0x09,0x60,0x00,0x01,0x00,0x68,0xDA,0x60,0x0C,0x03,0x63,0x28,0x90,0x37,0xA7,0x20,0x03,0xE0,0x5A,0xC1,0x94,0x36,0x35,0xC0,0x80,0x01,0x2B,0x01,0x14,0x1F,0xDA,0x82,0x94,0x56,0x37,0x92,0x20,0x09,0x80,0x00,0x84,0x88,0x2A,0xB4,0xA8,0x14,0x37,0x55,0x00,0x20,0x0F,0xD8,0xC3,0x94,0x37,0x75,0xC0,0x03,0xE1,0xA1,0x00,0x80,0x6A,0xDB,0x00,0x80,0xA3,0x58,0xC8,0x94,0x37,0x77,0x8C,0x20,0x09,0xA0,0x00,0xC8,0x03,0xE1,0xA1,0x00,0x00,0xA3,0x58,0x40,0x00,0x01,0x13,0x20,0x03,0xE0,0x5B,0x24,0x90,0x37,0xA4,0xC0,0x03,0xE1,0xA1,0xC1,0x94,0x37,0x74,0x20,0x03,0xE1,0xA3,0xC2,0x20,0x09,0xC0,0x00,0x21,0x90,0x37,0xA4,0xC0,0x03,0xE1,0xA1,0xC3,0x94,0x37,0x74,0x20,0x03,0xE1,0xA3,0x23,0x90,0x37,0xA5,0x90,0x40,0x0F,0xD8,0xC0,0x03,0xE1,0xA1,0xC4,0x94,0x37,0x75,0x0E,0x20,0x09,0xE0,0x00,0x00,0x80,0x6A,0xDB,0x90,0x84,0xA3,0x58,0x00,0x8C,0x43,0x62,0xC1,0x94,0x37,0x74,0xC0,0x03,0xE1,0xA0,0xC3,0x94,0x37,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0x20,0x0A,0x00,0x00,0x07,0x83,0x8E,0x2A,0x07,0x80,0x00,0x6A,0x07,0xBF,0x09,0xF2,0x07,0x05,0xFE,0x2A,0x07,0x00,0x00,0x6A,0x02,0x03,0x90,0x2A,0x02,0x00,0x00,0x6A,0x00,0x10,0x03,0x62,0x9D,0x20,0x0A,0x20,0x00,0x02,0x05,0xCC,0x28,0x01,0x83,0x41,0x62,0x02,0x00,0x00,0x68,0x01,0x85,0x30,0x28,0x01,0x80,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x0C,0x13,0x62,0x01,0x88,0x81,0x62,0x76,0x20,0x0A,0x40,0x00,0x02,0x04,0x10,0x2A,0x02,0x00,0x00,0x6A,0x00,0x10,0x03,0x62,0x01,0x85,0x61,0x62,0x02,0x04,0xA3,0x58,0x00,0x05,0xA1,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x65,0x20,0x0A,0x60,0x00,0x02,0xFF,0xFF,0xA8,0x02,0xFF,0xFF,0xE9,0x02,0x85,0x50,0x2A,0x02,0x80,0x00,0x6B,0x02,0x7C,0xA3,0x5A,0x00,0x14,0x9A,0x7B,0x01,0x94,0x0F,0xD9,0x00,0x14,0x03,0x62,0x5D,0x20,0x0A,0x80,0x00,0x02,0x00,0xA3,0x59,0x32,0x0C,0x02,0x64,0x01,0x80,0xA3,0x58,0x31,0x94,0x80,0x58,0x00,0x00,0x00,0x00,0x02,0x0C,0x1F,0xDA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x94,0x20,0x0A,0xA0,0x00,0x02,0x00,0x00,0x6E,0x00,0x00,0x61,0x20,0x02,0x10,0x20,0x5A,0x02,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x39,0x20,0x0A,0xC0,0x00,0x00,0x8C,0xA3,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x85,0x20,0x0A,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xA1,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x20,0x0B,0x98,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x0B,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x97,0x20,0x0B,0xB8,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x0B,0x8C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x0B,0x90,0x00,0x00,0x0A,0xC0,0x00,0x00,0x00,0x00,0x19,0x20,0x0B,0xD8,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x0B,0x94,0x00,0x00,0x0A,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x0B,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x85,0x04,0x0B,0xF8,0x00,0x00,0x00,0x00,0x00,0xF9,0x00,0x00,0x00,0x01,0xFF};



	/*int_tmp=ioread8(pht->addr_b0);
	printk("Dummy:read 8 bar0=%x\n",int_tmp);
	int_tmp=ioread8(pht->addr_b0+0x4);
	printk("Dummy:read 8 bar0+4=%x\n",int_tmp);*/
	/*iowrite8(0x9,pht->addr_b0);
	iowrite8(0x7,pht->addr_b0+0x1);
		iowrite32(0x20000000,pht->addr_b0);
		iowrite32(0x0185002A,pht->addr_b0+1);
	int_tmp=ioread8(pht->addr_b0);
	printk("Dummy:read 8 bar0=%x\n",int_tmp);
	int_tmp=ioread8(pht->addr_b0+4);
	printk("Dummy:read 8 bar0+4=%x\n",int_tmp);*/
	
	//printk("Dummy:write 8 bar0=0x1\n",int_tmp);

	/*int_tmp=ioread8(pht->addr_b0);
	printk("Dummy:read 8 bar0=%x\n",int_tmp);
	int_tmp=ioread32(pht->addr_b0);
	printk("Dummy:read 32 bar0=%x\n",int_tmp);
	int_tmp=ioread32(pht->addr_b0+0x1);
	printk("Dummy:read 32 bar0+1=%x\n",int_tmp);
	*/
/*
	printk("====================8====================\n");
	for(i=0;i<37;i++)
	{
		int_tmp=ioread8(pht->addr_b0+i);
		printk("Dummy:read [bar0+%i]=%x\n",i,int_tmp);	
	}
	
	/*for(i=0;i<37;i++)
	{
		iowrite8(code_arr[i],pht->addr_b0+i);
		//printk("Dummy:read [bar0+%i]=%x\n",i,int_tmp);	
	}


	printk("====================16====================\n");
	for(i=0;i<37;i++)
	{
		int_tmp=ioread16(pht->addr_b0+i);
		printk("Dummy:read [bar0+%i]=%x\n",i,int_tmp);	
	}
	printk("====================32====================\n");	
	for(i=0;i<37;i++)
	{
		int_tmp=ioread32(pht->addr_b0+i);
		printk("Dummy:read [bar0+%i]=%x\n",i,int_tmp);	
	}

	printk("====================8====================\n");
	for(i=0;i<37;i++)
	{
		int_tmp=ioread8(pht->addr_b0+i);
		printk("Dummy:read [bar0+%i]=%x\n",i,int_tmp);	
	}
*/
for(i=0;i<3000;i++){
	iowrite8(0,pht->addr_b0+i);
}
for(i=0;i<3000;i++){
	
		int_tmp=ioread8(pht->addr_b0+i);
		printk("Dummy:read [bar0+%i]=%x\n",i,int_tmp);
}


}

static int dummy_pci_test(struct pci_dev *pdev,struct dummy_device *pht)
{
	int retval;
	int int_tmp;
	int int_ret;
	int i;
	long lng_tmp;

	printk("----DUMMY PCI TEST - START\n");
	for(i=0;i<3;i++){
		lng_tmp=pci_resource_flags(pdev,i);
		printk("BAR[%i | %x] resource\n",i,i);
		printk("\t io=%i\n",IORESOURCE_IO & lng_tmp);
		printk("\t mem=%i\n",IORESOURCE_MEM & lng_tmp);
	}

	/*
	#define IORESOURCE_TYPE_BITS    0x00001f00      ///Resource type 
	#define IORESOURCE_IO           0x00000100
	#define IORESOURCE_MEM          0x00000200
	#define IORESOURCE_IRQ          0x00000400
	#define IORESOURCE_DMA          0x00000800
	#define IORESOURCE_BUS          0x00001000
	*/
	printk("---PCI config test ");

	int_ret=pci_read_config_word(pdev,PCI_DEVICE_ID ,&lng_tmp);
	printk("Dummy:PCI_DEVICE_ID  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_word(pdev,PCI_COMMAND ,&lng_tmp);
	printk("Dummy:PCI_COMMAND  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_word(pdev,PCI_COMMAND_IO ,&lng_tmp);
	printk("Dummy:PCI_COMMAND_IO  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_word(pdev,PCI_COMMAND_MEMORY  ,&lng_tmp);
	printk("Dummy:PCI_COMMAND_MEMORY   %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_word(pdev,PCI_STATUS  ,&lng_tmp);
	printk("Dummy:PCI_STATUS  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_byte(pdev,PCI_HEADER_TYPE  ,&lng_tmp);
	printk("Dummy:PCI_HEADER_TYPE  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_word(pdev,PCI_SUBSYSTEM_VENDOR_ID  ,&lng_tmp);
	printk("Dummy:PCI_SUBSYSTEM_VENDOR_ID  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_byte(pdev,PCI_INTERRUPT_LINE  ,&lng_tmp);
	printk("Dummy:PCI_INTERRUPT_LINE  %x,ret=%i\n",lng_tmp,int_ret);

	int_ret=pci_read_config_byte(pdev,PCI_INTERRUPT_PIN   ,&lng_tmp);
	printk("Dummy:PCI_INTERRUPT_PIN   %x,ret=%i\n",lng_tmp,int_ret);


/*
	#define PCI_VENDOR_ID           0x00     16 bits 
#define PCI_DEVICE_ID           0x02     16 bits 
#define              0x04     16 bits 
#define           0x1      Enable response in I/O space 
#define      0x2      Enable response in Memory space 
#define              0x06     16 bits 
#define         0x08     8 bits  
#define PCI_CLASS_DEVICE        0x0a     Device class 
#define PCI_HEADER_TYPE         0x0e     8 bits 
#define  PCI_HEADER_TYPE_NORMAL         0
#define  PCI_HEADER_TYPE_BRIDGE         1
#define  PCI_HEADER_TYPE_CARDBUS        2
#define  PCI_HEADER_TYPE_MULTI_FUNCTION 0x80
#define PCI_SUBSYSTEM_VENDOR_ID 0x2c     16 bits 
#define PCI_SUBSYSTEM_ID        0x2e     16 bits 
#define PCI_INTERRUPT_LINE      0x3c     8 bits 
#define       0x3d     8 bits 
#define PCI_MIN_GNT             0x3e     8 bits 
#define PCI_MAX_LAT             0x3f     8 bits 

#define PCI_REVISION            0x08     obsolete, use PCI_REVISION_ID 
#define PCI_SUBVENDOR_ID        0x2c     obsolete, use PCI_SUBSYSTEM_VENDOR_ID 
#define PCI_SUBDEVICE_ID        0x2e     obsolete, use PCI_SUBSYSTEM_ID 

 Bits in the PCI Status Register (PCI 2.3 spec) 
#define PCI_STATUS_RESERVED1    0x007
#define PCI_STATUS_INT_STATUS   0x008
#define PCI_STATUS_CAPABILITIES 0x010
#define PCI_STATUS_66MHZ        0x020
#define PCI_STATUS_RESERVED2    0x040
#define PCI_STATUS_FAST_BACK    0x080
#define PCI_STATUS_DEVSEL       0x600

#define PCI_STATUS_RESERVED_MASK_LO (PCI_STATUS_RESERVED1 | \
                PCI_STATUS_INT_STATUS | PCI_STATUS_CAPABILITIES | \
                PCI_STATUS_66MHZ | PCI_STATUS_RESERVED2 | PCI_STATUS_FAST_BACK)

#define PCI_STATUS_RESERVED_MASK_HI (PCI_STATUS_DEVSEL >> 8)

Bits in the PCI Command Register (PCI 2.3 spec) 
#define PCI_COMMAND_RESERVED    0xf800

#define PCI_COMMAND_RESERVED_MASK_HI (PCI_COMMAND_RESERVED >> 8)
 */




	/*bar0 test read/write*/
	printk("----------BARS test--------\n");
	int_tmp=0;

	int_tmp=ioread8(pht->addr_b0);
	printk("Dummy:read8 bar0=%x\n",int_tmp);
	int_tmp=ioread8(pht->addr_b1);
	printk("Dummy:read8 bar1=%x\n",int_tmp);
	int_tmp=ioread8(pht->addr_b2);
	printk("Dummy:read8 bar2=%x\n",int_tmp);

	int_tmp=ioread16(pht->addr_b0);
	printk("Dummy:read16 bar0=%x\n",int_tmp);
	int_tmp=ioread16(pht->addr_b1);
	printk("Dummy:read16 bar1=%x\n",int_tmp);
	int_tmp=ioread16(pht->addr_b2);
	printk("Dummy:read16 bar2=%x\n",int_tmp);

	int_tmp=ioread32(pht->addr_b0);
	printk("Dummy:read32 bar0=%x\n",int_tmp);
	int_tmp=ioread32(pht->addr_b1);
	printk("Dummy:read32 bar1=%x\n",int_tmp);
	int_tmp=ioread32(pht->addr_b2);
	printk("Dummy:read32 bar2=%x\n",int_tmp);


	printk("PCI test write/read dummy \n");
	iowrite8(0x1F,pht->addr_b0);
	printk("Dummy:write 8 bar0=0x1F\n",int_tmp);
	int_tmp=ioread8(pht->addr_b0);
	printk("Dummy:read 8 bar0=%x\n",int_tmp);
	iowrite16(0x1F,pht->addr_b0);
	printk("Dummy:write 16 bar0=0x1F\n",int_tmp);
	int_tmp=ioread16(pht->addr_b0);
	printk("Dummy:read 16 bar0=%x\n",int_tmp);
	iowrite32(0x1F,pht->addr_b0);
	printk("Dummy:write 32 bar0=0x1F\n",int_tmp);
	int_tmp=ioread32(pht->addr_b0);
	printk("Dummy:read 32 bar0=%x\n",int_tmp);

	printk("----------------------------\n");

	iowrite8(0x1F,pht->addr_b1);
	printk("Dummy:write 8 bar1=0x1F\n",int_tmp);
	int_tmp=ioread8(pht->addr_b1);
	printk("Dummy:read 8 bar1=%x\n",int_tmp);
	iowrite16(0x1F,pht->addr_b1);
	printk("Dummy:write 16 bar1=0x1F\n",int_tmp);
	int_tmp=ioread16(pht->addr_b1);
	printk("Dummy:read 16 bar1=%x\n",int_tmp);
	iowrite32(0x1F,pht->addr_b1);
	printk("Dummy:write 32 bar1=0x1F\n",int_tmp);
	int_tmp=ioread32(pht->addr_b1);
	printk("Dummy:read 32 bar1=%x\n",int_tmp);

	printk("----------------------------\n");

	iowrite8(0x1F,pht->addr_b2);
	printk("Dummy:write 8 bar2=0x1F\n",int_tmp);
	int_tmp=ioread8(pht->addr_b2);
	printk("Dummy:read 8 bar2=%x\n",int_tmp);
	iowrite16(0x1F,pht->addr_b2);
	printk("Dummy:write 16 bar2=0x1F\n",int_tmp);
	int_tmp=ioread16(pht->addr_b2);
	printk("Dummy:read 16 bar2=%x\n",int_tmp);
	iowrite32(0x1F,pht->addr_b2);
	printk("Dummy:write 32 bar2=0x1F\n",int_tmp);
	int_tmp=ioread32(pht->addr_b2);
	printk("Dummy:read 32 bar2=%x\n",int_tmp);

	printk("----------------------------\n");


	int_ret=0;
	printk("PCI config byte START\n");
	for (i=0;int_ret==0 && i<10000;i++){
		int_ret=pci_read_config_byte(pdev,i,&int_tmp);
		printk("Dummy:pci config byte[%i | %x]=%x\n",i,i,int_tmp);
		//printk("Dummy:pci config ret=%x\n",int_ret);
		
	}
	printk("PCI config byte END\n");

	int_ret=0;
	printk("PCI config word START\n");
	for (i=0;int_ret==0 && i<10000;i++){
		int_ret=pci_read_config_word(pdev,i,&int_tmp);
		printk("Dummy:pci config byte[%i | %x]=%x\n",i,i,int_tmp);
		//printk("Dummy:pci config ret=%x\n",int_ret);
		
	}
	printk("PCI config word END\n");

	int_ret=0;
	printk("PCI config dword START\n");
	for (i=0;int_ret==0 && i<10000;i++){
		int_ret=pci_read_config_dword(pdev,i,&int_tmp);
		printk("Dummy:pci config byte[%i | %x]=%x\n",i,i,int_tmp);
		//printk("Dummy:pci config ret=%x\n",int_ret);
		
	}
	printk("PCI config dword END\n");


	//printk("Dummy:pci config=%x\n",int_tmp);
	printk("Dummy:pci config ret=%x\n",int_ret);
	
	/*
	printk("Dummy:pci bars read/write test\n");
	int_tmp=ioread32(pht->addr_b0);
	printk("Dummy:read32 bar0=%x\n",int_tmp);
	int_tmp=ioread32(pht->addr_b1);
	printk("Dummy:read32 bar1=%x\n",int_tmp);
	int_tmp=ioread32(pht->addr_b2);
	printk("Dummy:read32 bar2=%x\n",int_tmp);
	*/

	printk("----DUMMY PCI TEST - END\n");	
	return 0;
}


/*----------------- TESTOVACI FCE ----------------- END*/

static irqreturn_t dummy_isr(int irq, void *data)
{
		struct dummy_device *dev = data;

	printk("Dummy: %s called\n", __func__);
		//atomic_inc(&dev->counter);
		//wake_up_interruptible(&dev->wait);

		return IRQ_HANDLED;
}

static int __devinit dummy_probe(struct pci_dev *pdev,
	const struct pci_device_id *pci_id)
{
	struct dummy_device *pht;
	int retval;
	int int_tmp;
	int int_ret;
	int i;
	long lng_tmp;

	printk("Dummy: %s called\n", __func__);
	retval = pci_enable_device(pdev);
	if (retval){
		dev_err(&pdev->dev, "unable to enable device\n");
	        printk("Dummy: unable to enable device\n");		
		goto err;
	}
		

	retval = pci_request_regions(pdev, "dummy");
	if (retval)
		goto err_dis;

	retval = -ENOMEM;
	pht = kzalloc(sizeof(*pht), GFP_KERNEL);

	if (pht == NULL) {
		dev_err(&pdev->dev, "unable to allocate device\n");
	        printk("Dummy: unable to allocate device\n");
		goto err_reg;
	}

	pht->addr_b0=pci_iomap(pdev, 0, 0);
	if (pht->addr_b0 == NULL) {
		dev_err(&pdev->dev, "can't remap bar0\n");
		printk("Dummy: can't remap bar0\n");
		goto err_fr;
	}
	pht->addr_b1=pci_iomap(pdev, 1, 0);
	if (pht->addr_b1 == NULL) {
		dev_err(&pdev->dev, "can't remap bar1\n");
		printk("Dummy: can't remap bar1\n");
		goto err_fr;
	}
	pht->addr_b2=pci_iomap(pdev, 2, 0);
	if (pht->addr_b2 == NULL) {
		dev_err(&pdev->dev, "can't remap bar2\n");
		printk("Dummy: can't remap bar2\n");
		goto err_fr;
	}
	
	//dummy_pci_test(pdev,pht);
	dummy_pci_iotest(pdev,pht);//=<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<load program to dsp
	dummy_pci_dspreset(pdev,pht);//reset dsp
	//00000bfc inc

	/*for(i=0;i<100;i++)
	{
		int_tmp=ioread8(pht->addr_b0+0xbfc);
		printk("Dummy:read [bar0+0xbfc]=%x\n",int_tmp);	
	}*/
	
	
/*
	pht->caddr = pci_iomap(pdev, 0, 0);
	if (pht->caddr == NULL) {
		dev_err(&pdev->dev, "can't remap conf space\n");
		printk("Dummy: can't remap conf space\n");
		goto err_fr;
	}


//nedari se namapovat
	pht->iaddr = pci_iomap(pdev, 2, 2);
	if (pht->iaddr == NULL) {
		dev_err(&pdev->dev, "can't remap input space\n");
		printk("Dummy: can't remap input space\n");
		goto err_unmc;
	}




//nedari se namapovat
	pht->oaddr = pci_iomap(pdev, 3, 0);
	if (pht->oaddr == NULL) {
		dev_err(&pdev->dev, "can't remap output space\n");
		printk("Dummy: can't remap output space\n");
		goto err_unmi;
	}
*/

/*TEST vypis konfigurace -----START
	printk("get pci dev revision:%i\n",get_dev_revision(pdev));
	printk("set pci dev revision:%i\n",set_dev_revision(pdev,2));
	printk("get pci dev revision:%i\n",get_dev_revision(pdev));
TEST vypis konfigurace -----END*/
	mutex_init(&pht->open_lock);
	spin_lock_init(&pht->regs_lock);
	init_waitqueue_head(&pht->wait);

	retval = request_irq(pdev->irq, dummy_isr,
			IRQF_SHARED | IRQF_DISABLED, "dummy", pht);
	if (retval) {
		dev_err(&pdev->dev, "can't establish ISR\n");
		printk("Dummy: can't establish ISR\n");
		goto err_unmo;
	}

	
	pci_set_drvdata(pdev, pht);

	return 0;
	err_unmo:
		pci_iounmap(pdev, pht->addr_b2);
	err_unmi:
		pci_iounmap(pdev, pht->addr_b1);
	err_unmc:
		pci_iounmap(pdev, pht->addr_b0);
	err_fr:
		kfree(pht);
	err_reg:
		pci_release_regions(pdev);
	err_dis:
		pci_disable_device(pdev);
	err:
		return retval;
}

static void __devexit dummy_remove(struct pci_dev *pdev)
{
	struct dummy_device *pht = pci_get_drvdata(pdev);

printk("Dummy: %s called\n", __func__);
	free_irq(pdev->irq, pht);

	pci_iounmap(pdev, pht->addr_b2);
	pci_iounmap(pdev, pht->addr_b1);
	pci_iounmap(pdev, pht->addr_b0);

	kfree(pht);

	pci_release_regions(pdev);

	pci_disable_device(pdev);
}

static int dummy_suspend(struct pci_dev *pdev, pm_message_t state)
{
printk("Dummy: %s called\n", __func__);
	synchronize_irq(pdev->irq);

	return 0;
}

static int dummy_resume(struct pci_dev *pdev)
{
printk("Dummy: %s called\n", __func__);
	return 0;
}


static struct pci_device_id dummy_pci_tbl[] __devinitdata = {
	{ 
	.vendor = DUMMY_VENDOR_ID,
	.device = DUMMY_DEVICE_ID,
	.subvendor = PCI_ANY_ID,
	.subdevice = PCI_ANY_ID,
	//.class = (DUMMY_CLASS_ID << 8),
	.class =0x11,
	.class_mask = 0xffff00 },//vzuyiti napr vypis vsech eth. kart (stejna maska)
	{ 0, }
};
MODULE_DEVICE_TABLE(pci, dummy_pci_tbl);

static struct pci_driver dummy_pci_driver = {
	.name = "dummy",
	.id_table = dummy_pci_tbl,
	.probe = dummy_probe,
	.remove = __devexit_p(dummy_remove),
	.suspend = dummy_suspend,
	.resume = dummy_resume,
};

static int __init dummy_init(void)
{
	int retval;

printk("Dummy: %s called\n", __func__);
/*
	dummy_class = class_create(THIS_MODULE, "dummy");
	if (IS_ERR(dummy_class)) {
		retval = PTR_ERR(dummy_class);
		printk("Dummy: can't register dummy class\n");
		goto err;
	}
*/

	retval = pci_register_driver(&dummy_pci_driver);
	if (retval) {
		printk("Dummy: can't register pci driver\n");
		goto err_class;
	}

	printk("Dummy Linux Driver, init OK\n");

	
	return 0;
err_class:
//	class_destroy(dummy_class);
//err:
	return retval;
}



static void __exit dummy_exit(void)
{
printk("Dummy: %s called\n", __func__);
	pci_unregister_driver(&dummy_pci_driver);

//	class_destroy(dummy_class);

	printk("Dummy: module successfully removed\n");
}

module_init(dummy_init);
module_exit(dummy_exit);

